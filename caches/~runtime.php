<?php  abstract class AbstractFreeBeforeDo extends FreeBase { abstract public function handle(& $app); } Abstract class AbstractFreeModel extends FreeBase{ const MUST_VALIDATE = 1; const EXISTS_VAILIDATE = 0; const VALUE_VAILIDATE = 2; const MODEL_INSERT = 1; const MODEL_UPDATE = 2; const MODEL_BOTH = 3; protected $_validate = array(); protected $_validate_field = array(); protected $_deal = array(); protected $db_config = ''; protected $db = ''; protected $table_name = ''; protected $db_tablepre = ''; protected $_pk_id = 'ID'; public $error = ''; protected $_is_auto = 1; protected $_is_hash = 1; protected $comparison = array('eq'=>'=','neq'=>'<>','gt'=>'>','egt'=>'>=','lt'=>'<','elt'=>'<=','notlike'=>'NOT LIKE','like'=>'LIKE'); abstract public function select($where = array(), $data = array() , $limit = array(), $order = array(), $group = '', $key=''); public function getTableName() { return $this->table_name; } public function regex($value,$rule) { $validate = array( 'require'=> '/.+/', 'email' => '/^\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*$/', 'url' => '/^http:\/\/[A-Za-z0-9]+\.[A-Za-z0-9]+[\/=\?%\-&_~`@[\]\':+!]*([^<>\"\"])*$/', 'currency' => '/^\d+(\.\d+)?$/', 'number' => '/\d+$/', 'zip' => '/^[1-9]\d{5}$/', 'integer' => '/^[-\+]?\d+$/', 'double' => '/^[-\+]?\d+(\.\d+)?$/', 'english' => '/^[A-Za-z]+$/', ); if(isset($validate[strtolower($rule)])) $rule = $validate[strtolower($rule)]; return preg_match($rule,$value)===1; } public function validation($data,$type=1) { if(!empty($this->_validate) && ($this->_is_auto == 1 || $this->_validate_field)) { foreach($this->_validate as $key=>$val) { if($this->_validate_field && !in_array($val[0],$this->_validate_field)) { continue; } if(0==strpos($val[2],'{%') && strpos($val[2],'}')) { $val[2] = L(substr($val[2],2,-1)); } $val[2] = sprintf($val[2],$data[$val[0]]); $val[3] = isset($val[3])?$val[3]:self::EXISTS_VAILIDATE; $val[4] = isset($val[4])?$val[4]:'regex'; if(!( empty($val[5]) || $val[5]== self::MODEL_BOTH || $val[5]== $type)) { continue; } switch($val[3]) { case self::MUST_VALIDATE: if(false === $this->_validationField($data,$val,$type)) { $this->error = $val[2]; return false; } break; case self::VALUE_VAILIDATE: if('' != trim($data[$val[0]])) { if(false === $this->_validationField($data,$val,$type)) { $this->error = $val[2]; return false; } } break; default: if(isset($data[$val[0]])) { if(false === $this->_validationField($data,$val,$type)) { $this->error = $val[2]; return false; } } } } if($this->_is_hash == 1 && !Free::getApp()->checkCsrf()) { $this->error = 'hash error.'; return false; } } $this->_validate_field = array(); return true; } private function _validationField($data,$val,$type) { switch($val[4]) { case 'function': case 'callback': $args = isset($val[6])?$val[6]:array(); array_unshift($args,$data[$val[0]]); if('function'==$val[4]) { return call_user_func_array(array('FreeValidator', $val[1]), $args); }else{ return call_user_func_array(array(&$this, $val[1]), $args); } case 'in': $range = is_array($val[1])?$val[1]:explode(',',$val[1]); return in_array($data[$val[0]] ,$range); case 'between': list($min,$max) = explode(',',$rule); return $data[$val[0]]>=$min && $data[$val[0]]<=$max; case 'equal': return $data[$val[0]] == $val[1]; case 'nequal': return $data[$val[0]] != $val[1]; case 'length': $length = mb_strlen($data[$val[0]],'utf-8'); if(strpos($val[1],',')) { list($min,$max) = explode(',',$val[1]); return $length >= $min && $length <= $max; }else{ return $length == $val[1]; } case 'expire': list($start,$end) = explode(',',$val[0]); if(!is_numeric($start)) $start = strtotime($start); if(!is_numeric($end)) $end = strtotime($end); return $_SERVER['REQUEST_TIME'] >= $start && $_SERVER['REQUEST_TIME'] <= $end; case 'ip_allow': return in_array(get_client_ip(),explode(',',$val[1])); case 'ip_deny': return !in_array(get_client_ip(),explode(',',$val[1])); case 'unique': $where = array($val[0] => $data[$val[0]]); if(isset($val[6])) { $uns = strpos($val[6],',') ? explode(',',$val[6]) : array($val[6]); foreach($uns as $key => $un) { $where[$un] = $data[$un]; } } if($type == self::MODEL_UPDATE) { !empty($this->where[$this->_pk_id]) && $where = array_merge($where,array($this->_pk_id=>array('neq',$this->where[$this->_pk_id]))); is_array($val[6]) && $where = array_merge($where,$val[6]); } return $this->_unique($where); break; case 'regex': default: return $this->regex($data[$val[0]],$val[1]); } return true; } protected function _unique($where) { return $this->select($where) ? false : true; } public function setValidate($_v=array()) { $this->_validate = array_merge($this->_validate,$_v); } public function getError() { return $this->error; } public function setDeal($_v=array()) { $this->_deal = array_merge($this->_deal,$_v); } public function deal(&$data,$type=1) { if(isset($data['__hash__'])) { unset($data['__hash__']); } if(!empty($this->_deal) && $this->_is_auto == 1 ) { foreach($this->_deal as $key=>$val) { if(!( empty($val[3]) || $val[3]== self::MODEL_BOTH || $val[3]== $type)) { continue; } switch($val[2]) { case 'function': case 'callback': $args = isset($val[4])?$val[4]:array(); array_unshift($args,$data[$val[0]]); if('function'==$val[2]) { $data[$val[0]] = call_user_func_array($val[1], $args); }else{ $data[$val[0]] = call_user_func_array(array(&$this, $val[1]), $args); } default: break; } } } } public function openAuto() { $this->_is_auto = 1; return $this; } public function closeAuto() { $this->_is_auto = 0; return $this; } public function setValidateField($field) { is_array($field) && $this->_validate_field = $field; return $this; } public function openHash() { $this->_is_hash = 1; return $this; } public function closeHash() { $this->_is_hash = 0; return $this; } } abstract class AbstractFreeServer extends FreeBase { public $model; public function __construct() { $this->model(); } abstract public function model(); public function getError() { return $this->error; } public function getModel() { return $this->model; } } final class FreeApplication extends FreeBase { private $_module; private $_controller; private $_action; private $controller; private $action; private $_run_num = 1; public function __construct() { $param = $this->getComponent('route'); $this->_module = $param->route_m(); $this->_controller = $param->route_c(); $this->_action = $param->route_a(); } public function __destruct() { if(FREE_DEBUG) { echo FreeDebug::debug(); } } public function run($m='',$c='',$a='') { $this->_run_num ++; if($this->_run_num > 10) { throw new FreeException('run extends the maximum','0'); } !empty($m) && $this->_module = $m; !empty($c) && $this->_controller = $c; !empty($a) && $this->_action = $a; $this->controller = $this->loadController(); $this->action = $this->_action. 'Action' ; if (method_exists($this->controller, $this->action)) { if (preg_match('/^[_]/i', $this->action)) { throw new FreeException('You are visiting the action is to protect the private action','102'); } else { $this->doFilter(); call_user_func(array($this->controller, 'doBefore')); call_user_func(array($this->controller, $this->action)); call_user_func(array($this->controller, 'doAfter')); } } else { throw new FreeException($this->action.'	Action does not exist.','102'); } } public function get() { return array($this->_module,$this->_controller,$this->_action); } private function loadController() { $filename = ucfirst($this->_controller); $app_config = Free::loadConfig('application',APP); !defined('PLATFORM_VERSION') && define('PLATFORM_VERSION' , isset($app_config['version']) ? $app_config['version'] : 'base'); $classname = $filename . 'BaseController'; $filepath = FREE_PATH.'src'.DIRECTORY_SEPARATOR.'apps'.DIRECTORY_SEPARATOR.'base'.DIRECTORY_SEPARATOR.$this->_module.DIRECTORY_SEPARATOR. lcfirst(APP). DIRECTORY_SEPARATOR . $classname.'.php'; if (file_exists($filepath)) { include_once $filepath; if(PLATFORM_VERSION !== 'base') { $filepath = FREE_PATH.'src'.DIRECTORY_SEPARATOR.'apps'.DIRECTORY_SEPARATOR.PLATFORM_VERSION.DIRECTORY_SEPARATOR.$this->_module.DIRECTORY_SEPARATOR.$app_config['controller-path'] .DIRECTORY_SEPARATOR. $filename.'Controller.php'; if(file_exists($filepath)) { $classname = $filename . 'Controller'; include_once $filepath; } } return new $classname(); } else { throw new FreeException($filepath . ' that is a controller.','100'); } } public function doFilter() { $forward = $this->getFilter()->handle($this); if($forward !== false) { list($m,$c,$a) = explode('/',$forward ); $this->controller->forward($m,$c,$a); }else{ return true; } } public function getController() { return $this->controller ; } public function setController($controller) { $this->controller = $controller; } } class FreeComponent { protected $_paths = array(); protected $_classes = array(); public function __construct() { $this->_init(); } public function get($name,$option = array(),$is_new = 0) { if (array_key_exists($name,$this->_paths)) { $path = FREE_PATH . $this->_paths[$name] . '.php'; $key = md5($path); if(!isset($this->_classes[$key]) || $is_new === 1) { if(file_exists($path)) { include_once $path; $class_name = substr(strrchr($this->_paths[$name],'/'),1); $this->_classes[$key] = new $class_name($option); }else{ return false; } } return $this->_classes[$key]; }else{ return false; } } public function register($path) { is_array($path) && $this->_paths = array_merge($this->_paths,$path); } private function _init() { $paths = array( 'route' => 'free/libs/route/FreeDefaultRoute', 'template' => 'free/libs/view/FreeTemplate', 'cache' => 'free/libs/cache/FreeFileCache', 'db' => 'free/libs/db/FreeOracleDb', 'request' => 'free/libs/http/FreeHttpRequest', 'response' => 'free/libs/http/FreeHttpResponse', 'token' => 'free/libs/token/FreeSecurityToken', 'page' => 'free/libs/view/FreePage', 'mongo_db' => 'free/libs/db/FreeMongoDb', 'log_container' => 'free/libs/log/FreeLogContainer', ); $upaths = Free::loadConfig('component'); $this->_paths = is_array($upaths) ? array_merge($paths,$upaths) : $paths; } } class FreeController extends FreeBase{ public $_module; public $_controller; public $_action; private $_view; protected $_lang = array(); private $_out_put = array(); public $_list_rows = 20; protected $_is_csrf = 0; public function __construct() { list($this->_module, $this->_controller,$this->_action)= Free::loadSysClass('FreeApplication')->get(); $this->loadLanguage('system,'.$this->_module); Free::loadSysClass('FreeApplication')->setController($this); } public function __destruct() { } final public function assign($name,$value='') { if(is_array($name)) { $this->_out_put = array_merge($this->_out_put,$name); }elseif(is_object($name)){ foreach($name as $key =>$val) $this->_out_put[$key] = $val; }else { $this->_out_put[$name] = $value; } } public function loadLanguage($modules) { static $LANG_MODULES = array(); $LANG = array(); static $lang = ''; $lang = FreeCookie::get('free_lang'); empty($lang) && $lang = Free::loadConfig('system', 'lang'); if (!empty($modules)) { $modules = explode(',', $modules); foreach ($modules AS $m) { if (!isset($LANG_MODULES[$m])&&file_exists(FREE_PATH . 'src' . DIRECTORY_SEPARATOR . 'languages' . DIRECTORY_SEPARATOR . $lang . DIRECTORY_SEPARATOR . $m . '.lang.php')) { require FREE_PATH . 'src' . DIRECTORY_SEPARATOR . 'languages' . DIRECTORY_SEPARATOR . $lang . DIRECTORY_SEPARATOR . $m . '.lang.php'; } } } is_array($LANG) && $this->_lang = array_merge($this->_lang,$LANG); } public function lang($name) { return isset($this->_lang[$name]) ? $this->_lang[$name] : $this->_lang['no_language'] . "[$name]"; } public function template($__m__='',$__filename__='',$__style__='default',$__app__=APP) { if(!$this->_view) { $this->_view = Free::loadSysClass('FreeView'); } if (!$__style__) { $__style__ = 'default'; } empty($__m__) && $__m__ = $this->_module; empty($__filename__) && $__filename__ = $this->_controller . '_' . $this->_action; extract($this->_out_put, EXTR_SKIP); include $this->_view->templateResolve($__m__,$__filename__,$__style__,$__app__); } final public function doBefore() { $base_filepath = FREE_PATH .'src'.DIRECTORY_SEPARATOR.'library'.DIRECTORY_SEPARATOR.'base'; $base_classname = APP . 'BeforeBaseDo'; if (file_exists($base_filepath . DIRECTORY_SEPARATOR . $base_classname . '.php')) { if(PLATFORM_VERSION !== 'base') { $filepath = FREE_PATH.'src'.DIRECTORY_SEPARATOR.'library'.DIRECTORY_SEPARATOR.PLATFORM_VERSION.DIRECTORY_SEPARATOR; $classname = APP . 'BeforeDo'; if(file_exists($filepath . DIRECTORY_SEPARATOR . $classname . '.php')) { Free::loadClass($base_classname, $base_filepath,0); return Free::loadClass($classname, $filepath)->handle($this); } } return Free::loadClass($base_classname, $base_filepath)->handle($this); }else{ return false; } } public function doAfter() { } final public function forward($m,$c,$a) { if($m !== $this->_module || $c !== $this->_controller || $a !== $this->_action) { $app_class = Free::loadSysClass('FreeApplication')->run($m,$c,$a); die; } } public function rediect() { } public function pageConfig() { } function executeTime($start = '') { $stime = $start ? explode(' ', $start) : explode(' ', SYS_START_TIME); $etime = explode(' ', microtime()); return number_format(($etime [1] + $etime [0] - $stime [1] - $stime [0]), 6); } public function showMessage($msg, $url_forward = '', $status=1,$data ='', $ms = 1250) { echo $msg; if(!$status) exit; } public function checkCsrf() { if(Free::loadConfig('system','is_check_csrf') && $this->_is_csrf ===0) { if(!$this->getComponent('token')->validateToken($this->getRequest()->getPost('__hash__'),'csrf_token')) { return false; } $this->getComponent('token')->deleteToken('csrf_token'); unset($_POST['__hash__']); $this->_is_csrf ++; } return true; } } class FreeException extends Exception { const ERROR_SYSTEM_ERROR = '0'; const ERROR_CLASS_NOT_EXIST = '100'; const ERROR_CLASS_TYPE_ERROR = '101'; const ERROR_CLASS_METHOD_NOT_EXIST = '102'; const ERROR_OBJECT_NOT_EXIST = '103'; const ERROR_PARAMETER_TYPE_ERROR = '110'; const ERROR_CONFIG_ERROR = '120'; const ERROR_RETURN_TYPE_ERROR = '130'; const ERROR_NOT_EXIST_HANDLE = '404'; const ERROR_NOT_EXIST_TEMPLATE = '104'; public function __construct($message, $code = 0) { $message = $this->buildMessage($message, $code); $file = $this->getFile(); $line = $this->getLine(); include(PC_PATH . 'base/view/error.php'); die(); } public function buildMessage($message, $code) { $message = str_replace(array("<br />", "<br>", "\r\n"), '', $message); eval('$message="' . addcslashes($this->messageMapper($code), '"') . '";'); return $message; } protected function messageMapper($code) { $messages = array( self::ERROR_SYSTEM_ERROR => 'System error \'$message\'.', self::ERROR_CLASS_TYPE_ERROR => 'Incorrect class type \'$message\'.', self::ERROR_CLASS_NOT_EXIST => 'Unable to create instance for \'$message\' , class is not exist.', self::ERROR_CLASS_METHOD_NOT_EXIST => 'Unable to access the method \'$message\' in current class , the method is not exist or is protected.', self::ERROR_OBJECT_NOT_EXIST => 'Unable to access the object in current class \'$message\' ', self::ERROR_CONFIG_ERROR => 'Incorrect config. the config about \'$message\' error.', self::ERROR_PARAMETER_TYPE_ERROR => 'Incorrect parameter type \'$message\'.', self::ERROR_RETURN_TYPE_ERROR => 'Incorrect return type for \'$message\'.', self::ERROR_NOT_EXIST_HANDLE => 'Incorrect handle type for \'$message\'.',); return isset($messages[$code]) ? $messages[$code] : '$message'; } } class FreeFilter extends FreeBase{ private $_filters = array(); private $_is_handled = 0; public function __construct() { self::_init(); } public function handle(& $app) { if (count($this->_filters) < 1) { return false; } $this->_is_handled++; $forward = $this->getHandler(); return $forward; } public function getHandler() { $this->registerComponent($this->_filters); foreach($this->_filters as $key => $val) { $forward = $this->getComponent($key)->handle(); unset($this->_filters[$key]); if($forward !== false) { return $forward; } } return false; } public function register($filter=array()) { is_array($filter) && $this->_filters += $filter; } public function remove($filter_name) { if(isset($this->_filters[$filter_name])) { unset($this->_filters[$filter_name]); } } private function _init() { $_filter = array( 'default_filter'=>'free/libs/filter/FreeDefaultFilter', ); $app_config = Free::loadConfig('application',APP); $this->_filters = isset($app_config['filter'])&&is_array($app_config['filter']) ? array_merge($_filter,$app_config['filter']) : $_filter; } } class FreeInit extends FreeBase{ public function __construct() { $this->systemInit(); $this->resourceInit(); $this->gzipInit(); $this->sessionInit(); } private function systemInit() { define('CACHE_PATH', FREE_PATH.'caches'.DIRECTORY_SEPARATOR); define('SITE_PROTOCOL', isset($_SERVER['SERVER_PORT']) && $_SERVER['SERVER_PORT'] == '443' ? 'https://' : 'http://'); define('SITE_URL', (isset($_SERVER['HTTP_HOST']) ? $_SERVER['HTTP_HOST'] : '')); define('SYS_START_TIME', microtime()); Free::loadConfig('system','errorlog') ? set_error_handler('myErrorHandler') : error_reporting(E_ERROR | E_WARNING | E_PARSE); function_exists('date_default_timezone_set') && date_default_timezone_set(Free::loadConfig('system','timezone')); header('Content-type: text/html; charset='.Free::loadConfig('system','charset')); define('SYS_TIME', time()); define('DEFAULT_PROVINCE', Free::loadConfig('system','default_province')); define('DEFAULT_CITY', Free::loadConfig('system','default_city')); define('EXTENTION_PATH', FREE_PATH.'extention'.DIRECTORY_SEPARATOR); } private function resourceInit() { define('WEB_PATH',Free::loadConfig('system','web_path')); define('JS_PATH',Free::loadConfig('system','js_path')); define('CSS_PATH',Free::loadConfig('system','css_path')); define('IMG_PATH',Free::loadConfig('system','img_path')); define('WAP_UCD_PATH',Free::loadConfig('system','wap_ucd_path')); define('CSS_PATH',Free::loadConfig('system','css_path')); define('UPLOAD_PATH',Free::loadConfig('system','upload_url')); define('UPLOAD_PATH_',Free::loadConfig('system','upload_path')); } private function sessionInit(){ $this->getComponent('session'); } private function gzipInit() { if(Free::loadConfig('system','gzip') && function_exists('ob_gzhandler')) { ob_start('ob_gzhandler'); } else { ob_start(); } } } function myErrorHandler($errno, $errstr, $errfile, $errline) { if ($errno == 8) { return ''; } $errfile = str_replace(FREE_PATH, '', $errfile); if (Free::loadConfig('system', 'errorlog')) { error_log(date('m-d H:i:s', SYS_TIME) . ' | ' . $errno . ' | ' . str_pad($errstr, 30) . ' | ' . $errfile . ' | ' . $errline . "\r\n", 3, CACHE_PATH . 'error_log.php'); } else { $str = '<div style="font-size:12px;text-align:left; border-bottom:1px solid #9cc9e0; border-right:1px solid #9cc9e0;padding:1px 4px;color:#000000;font-family:Arial, Helvetica,sans-serif;"><span>errorno:' . $errno . ',str:' . $errstr . ',file:<font color="blue">' . $errfile . '</font>,line' . $errline . '<br /><a href="http://faq.phpcms.cn/?type=file&errno=' . $errno . '&errstr=' . urlencode($errstr) . '&errfile=' . urlencode($errfile) . '&errline=' . $errline . '" target="_blank" style="color:red">Need Help?</a></span></div>'; echo $str; } } class FreeView extends FreeBase { public function templateResolve($m,$filename,$style,$app = APP) { $app_configs = Free::loadConfig('application',$app); $version = $app_configs['version']; $template_component = $this->getComponent('template'); $tpl_suffix = $template_component->getTplSuffix(); $complie_suffix = $template_component->getComplieSuffix(); $app = strtolower($app); $base_template_path = FREE_PATH . 'view' . DIRECTORY_SEPARATOR . 'base' . DIRECTORY_SEPARATOR .$app. 'templates'. DIRECTORY_SEPARATOR . $style . DIRECTORY_SEPARATOR . $m . DIRECTORY_SEPARATOR; $base_complie_path = CACHE_PATH . 'template_base' . DIRECTORY_SEPARATOR .$app. 'templates' . DIRECTORY_SEPARATOR . $style . DIRECTORY_SEPARATOR . $m . DIRECTORY_SEPARATOR; if($version === 'base') { if(!file_exists($base_template_path . $filename . $tpl_suffix)) { $base_template_path = FREE_PATH . 'view' . DIRECTORY_SEPARATOR . 'base' . DIRECTORY_SEPARATOR .$app. 'templates'. DIRECTORY_SEPARATOR . 'default' . DIRECTORY_SEPARATOR . $m . DIRECTORY_SEPARATOR; $base_complie_path = CACHE_PATH . 'template_base' . DIRECTORY_SEPARATOR .$app. 'templates' . DIRECTORY_SEPARATOR . 'default' . DIRECTORY_SEPARATOR . $m . DIRECTORY_SEPARATOR; } $template = $template_component->compile($filename,$base_template_path,$base_complie_path); if($template === false) { throw new FreeException($base_template_path . $filename . $tpl_suffix .' Template does not exist.' ,'104'); }else{ return $template; } }else{ $template_path = FREE_PATH . (isset($app_configs['template-path']) ? $app_configs['template-path'] :'view' . DIRECTORY_SEPARATOR . PLATFORM_VERSION . DIRECTORY_SEPARATOR .$app. 'templates' . DIRECTORY_SEPARATOR ). $style . DIRECTORY_SEPARATOR . $m . DIRECTORY_SEPARATOR; $complie_path = CACHE_PATH . (isset($app_configs['template-complie-path']) ? $app_configs['template-complie-path'] : 'template_' . PLATFORM_VERSION . DIRECTORY_SEPARATOR .$app. 'templates' . DIRECTORY_SEPARATOR) . $style . DIRECTORY_SEPARATOR . $m . DIRECTORY_SEPARATOR; if(!file_exists($template_path . $filename . $tpl_suffix)) { $template_path = FREE_PATH . (isset($app_configs['template-path']) ? $app_configs['template-path'] : 'view' . DIRECTORY_SEPARATOR . PLATFORM_VERSION . DIRECTORY_SEPARATOR .$app. 'templates' . DIRECTORY_SEPARATOR ) . 'default' . DIRECTORY_SEPARATOR . $m . DIRECTORY_SEPARATOR; $complie_path = CACHE_PATH .(isset($app_configs['template-complie-path']) ? $app_configs['template-complie-path'] : 'template_' . PLATFORM_VERSION . DIRECTORY_SEPARATOR .$app. 'templates' . DIRECTORY_SEPARATOR). 'default' . DIRECTORY_SEPARATOR . $m . DIRECTORY_SEPARATOR; } $template =$template_component->compile($filename,$template_path,$complie_path); if($template === false) { return self::templateResolve($m,$filename,$style,'base'); }else{ return $template; } } } } interface IFreeTag { public function count($data); } class FreeModel extends AbstractFreeModel{ protected $_validate = array(); public function __construct($table_name='') { $this->db_tablepre = Free::loadConfig('system','tablepre'); !empty($table_name) && $this->table_name = $table_name; $this->table_name = $this->db_tablepre .strtoupper($this->table_name); $this->db = $this->getComponent('db'); } final public function select($where = array(), $data = array(), $limit = '', $order = '', $group = '', $key='') { return $this->db->select($data, $this->table_name, $where, $limit, $order, $group, $key); } final public function listInfo($where = array(), $data=array(), $order = '', $page = 1, $pagesize = 0, $key='',$page_style='default', $setpages = 10,$urlrule = '') { $page_class = $this->getComponent('page'); $this->number = $this->count($where); $page = max(intval($page), 1); $this->pages = $page_class->show($this->number, $page, $pagesize, $page_style,$setpages,$urlrule); $pagesize = $page_class->getPageRow(); $offset = $pagesize*($page-1); $array = array(); if ($this->number > 0) { return $this->select($where, $data, "$offset, $pagesize", $order, '', $key); } else { return array(); } } final public function getOne($where = array(), $data = array(), $order = '', $group = '') { return $this->db->getOne($data, $this->table_name, $where, $order, $group); } final public function query($sql) { return $this->db->query($sql); } final public function insert($data, $return_insert_id = false, $replace = false) { if($this->validation($data,1)) { $this->deal($data,1); return $this->db->insert($data, $this->table_name, $return_insert_id, $replace); }else{ return false; } } final public function insertId() { return $this->db->insertId(); } final public function update($data, $where = array()) { $this->where = $where; if($this->validation($data,2)) { $this->deal($data,2); return $this->db->update($data, $this->table_name, $where); }else{ return false; } } final public function delete($where=array()) { return $this->db->delete($this->table_name, $where); } public function count($where = array()) { $r = $this->getOne($where, "COUNT(*) AS TNUM"); return $r['TNUM']; } final public function affectedRows() { return $this->db->affectedRows(); } public function getPrimary() { return $this->db->getPrimary($this->table_name); } final public function getFields($table_name = '') { if (empty($table_name)) { $table_name = $this->table_name; } else { $table_name = $this->db_tablepre.$table_name; } return $this->db->getFields($table_name); } final public function tableExists($table){ return $this->db->tableExists($this->db_tablepre.$table); } public function fieldExists($field) { return $this->db->fieldExists($this->table_name, $field); } final public function listTables() { return $this->db->listTables(); } final public function fetchArray() { $data = array(); while($r = $this->db->fetchNext()) { $data[] = $r; } return $data; } final public function version() { return $this->db->version(); } final public function updateA($column,$val,$table, $where = '') { return $this->db->updateA($column,$val,$table, $where); } } class FreeMongoModel extends FreeModel{ protected $_validate = array(); public function __construct($table_name='') { $this->db_tablepre = Free::loadConfig('system','tablepre'); !empty($table_name) && $this->table_name = $table_name; $this->table_name = strtolower($this->db_tablepre .$this->table_name); $this->db = $this->getComponent('mongo_db'); } public function count($where = array()) { $r = $this->db->count($this->table_name,$where); return $r; } public function getPrimary() { return $this->_pk_id; } } function str_cut($string, $length, $dot = true,$start=0,$charset='utf-8') { return FreeString::substr($string, $start, $length, $charset, $dot = false); } function C($file, $key = '', $default = '', $reload = false) { return Free::loadConfig($file, $key, $default, $reload); } function M($classname='',$m='') { $model = Free::loadModel($classname,$m); if($model !== false) { return $model; }else{ static $WXMODEL = array(); if(!isset($WXMODEL[$m . '-' . $classname])) { $WXMODEL[$m . '-' . $classname] = new FreeModel($classname); } return $WXMODEL[$m . '-' . $classname]; } } function S($classname, $m, $initialize = 1) { return Free::loadAppClass($classname . 'Server', $m , $initialize); } function L($name) { return Free::getApp()->lang($name); } function U($action, $args = array(), $anchor = '', $rediect = '',$script='') { $router = Free::getApp()->getComponent('route'); if(is_array($rediect)) { foreach($rediect as $key => $r) { $args[$key] = FreeSecurity::encrypt($r); } } $url = $router->assemble($action, $args,$script); $url .= $anchor ? '#' . $anchor : ''; return $url; } function E($et) { return Free::loadClass($et, FREE_PATH . 'extension' . DIRECTORY_SEPARATOR); } if ( false === function_exists('lcfirst') ){ function lcfirst( $str ) { return (string)(strtolower(substr($str,0,1)).substr($str,1));} } function dump($var, $echo=true, $label=null, $strict=true) { $label = ($label === null) ? '' : rtrim($label) . ' '; if (!$strict) { if (ini_get('html_errors')) { $output = print_r($var, true); $output = "<pre>" . $label . htmlspecialchars($output, ENT_QUOTES) . "</pre>"; } else { $output = $label . " : " . print_r($var, true); } } else { ob_start(); var_dump($var); $output = ob_get_clean(); if (!extension_loaded('xdebug')) { $output = preg_replace("/\]\=\>\n(\s+)/m", "] => ", $output); $output = '<pre>' . $label . htmlspecialchars($output, ENT_QUOTES) . '</pre>'; } } if ($echo) { echo($output); return null; }else return $output; } function getTplCache($name, $times = 0) { $path = 'tpl_data'; if(!($cache_data = Free::getApp()->getComponent('cache')->get($name, $path))) { return false; } if (SYS_TIME - $cache_data['ctime'] >= $times) { return false; } else { return $cache_data['data']; } } function setTplCache($name,$data) { $path = 'tpl_data'; $cache_data['ctime'] = SYS_TIME; $cache_data['data'] = $data; return Free::getApp()->getComponent('cache')->set($name,$cache_data,$path,24*3600); } class FreeConnect { const CONNECT_TIMEOUT = 15; const CONNECT_DEBUG_TIME = 1; static public function ucFopen($url, $limit = 0, $post = '', $cookie = '', $bysocket = FALSE, $ip = '', $timeout = '', $block = TRUE) { $start = microtime(); empty($timeout) && $timeout = CONNECT_TIMEOUT; if ($post) { $return = ''; $matches = parse_url($url); !isset($matches['host']) && $matches['host'] = ''; !isset($matches['path']) && $matches['path'] = ''; !isset($matches['query']) && $matches['query'] = ''; !isset($matches['port']) && $matches['port'] = ''; $host = $matches['host']; $path = $matches['path'] ? $matches['path'] . ($matches['query'] ? '?' . $matches['query'] : '') : '/'; $port = !empty($matches['port']) ? $matches['port'] : 80; $out = "POST $path HTTP/1.0\r\n"; $out .= "Accept: */*\r\n"; $out .= "Accept-Language: zh-cn\r\n"; $out .= "Content-Type: application/x-www-form-urlencoded\r\n"; $out .= "User-Agent: $_SERVER[HTTP_USER_AGENT]\r\n"; $out .= "Host: $host:$port\r\n"; $out .= 'Content-Length: ' . strlen($post) . "\r\n"; $out .= "Connection: Close\r\n"; $out .= "Cache-Control: no-cache\r\n"; $out .= "Cookie: $cookie\r\n\r\n"; $out .= $post; $fp = @fsockopen(($ip ? $ip : $host), $port, $errno, $errstr, $timeout); if (!$fp) { return ''; } else { @fwrite($fp, $out); if (!$status['timed_out']) { while (!feof($fp)) { if (($header = @fgets($fp)) && ($header == "\r\n" || $header == "\n")) { break; } } $stop = false; while (!feof($fp) && !$stop) { $data = fread($fp, ($limit == 0 || $limit > 118192 ? 118192 : $limit)); $return .= $data; if ($limit) { $limit -= strlen($data); $stop = $limit <= 0; } } } @fclose($fp); self::toLog($start,$url,$post); return $return; } } else { $result =self::curlOpen($url, $limit, $post, $cookie, $bysocket, $ip, $timeout, $block); self::toLog($start,$url,$post); return $result; } } static public function curlOpen($url, $limit = 0, $post = '', $cookie = '', $bysocket = FALSE, $ip = '', $timeout = 1, $block = TRUE) { if (!$url) die('url is null'); $ch = curl_init(); curl_setopt($ch, CURLOPT_URL, $url); curl_setopt($ch, CURLOPT_HEADER, 0); if ($post) { curl_setopt($ch, CURLOPT_POST, 1); curl_setopt($ch, CURLOPT_POSTFIELDS, $post); } curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1); curl_setopt($ch, CURLOPT_BINARYTRANSFER, 1); curl_setopt($ch, CURLOPT_TIMEOUT, $timeout); if ($cookie) curl_setopt($ch, CURLOPT_COOKIE, $cookie); $data = curl_exec($ch); curl_close($ch); return $data; } static public function toLog($start,$url,$param) { if( CONNECT_DEBUG_TIME != 0) { } return true; } static public function rpcFopen($url, $request, $limit = 0, $timeout = '') { if (!$url) { die('url is null'); } $start = microtime(); empty($timeout) && $timeout = CONNECT_TIMEOUT; $urlarr = parse_url($url); $host = $urlarr['host']; $path = $urlarr['path']; $len = strlen($request); $hander = "POST $path HTTP/1.1\r\n"; $hander .= "Host: $host\r\n"; $hander .= "Content-type: application/json\r\n"; $hander .= "Connection: Close\r\n"; $hander .= "Content-Length: $len\r\n"; $hander .= "\r\n"; $hander .= $request . "\r\n"; $handerarr[0] = $hander; $ch = curl_init(); curl_setopt($ch, CURLOPT_URL, $url); curl_setopt($ch, CURLOPT_HEADER, 0); curl_setopt($ch, CURLOPT_HTTPHEADER, $handerarr); curl_setopt($ch, CURLOPT_POST, 1); curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1); curl_setopt($ch, CURLOPT_BINARYTRANSFER, 1); curl_setopt($ch, CURLOPT_TIMEOUT, $timeout); $data = curl_exec($ch); curl_close($ch); $data = json_decode($data, true); self::toLog($start,$url,$request); return $data; } static public function eduPost($interface, $method, $params = array(), $is_encode = 1, $is_resources = 0){ $request = array(); $request['mac'] = md5(time()); $request['head'] = array('serialNumber' => time(), 'method' => $method, 'version' => '1'); if ($is_encode) { $authcode = array('password','newpassword'); foreach ($params as $k => $val) { if( in_array(strtolower($k), $authcode) && !empty($val)){ $params[$k] = md5($val); } if (in_array(strtolower($k), $authcode) && !empty($val)) { $params[$k] = authcode($params[$k], 'ENCODE'); } } } $request['body'] = $params; $request = json_encode($request); $return = self::rpcFopen($interface, $request); return $return; } } class FreeConvert { public static function convert($str, $toEncoding, $fromEncoding, $ifMb = true) { if (!strcasecmp($toEncoding, $fromEncoding)) return $str; switch (gettype($str)) { case 'string': if ($ifMb && function_exists('mb_convert_encoding')) $str = mb_convert_encoding($str, $toEncoding, $fromEncoding); else { !$toEncoding && $toEncoding = 'GBK'; !$fromEncoding && $fromEncoding = 'GBK'; Free::loadClass('FreeGeneralConverter',PC_PATH . 'libs/convert',0); $converter = Free::loadClass('IFreeConverter',PC_PATH . 'libs/convert',1); $str = $converter->convert($str, $fromEncoding, $toEncoding); } break; case 'array': foreach ($str as $key => $value) { is_object($value) && $value = get_object_vars($value); $str[$key] = self::convert($value, $toEncoding, $fromEncoding, $ifMb); } break; default: break; } return $str; } public static function gbkToUtf8($srcText) { return iconv('GBK', 'UTF-8', $srcText); $this->getTableIndex(); $tarText = ''; for ($i = 0; $i < strlen($srcText); $i += 2) { $h = ord($srcText[$i]); if ($h > 127 && isset($this->TableIndex[$this->EncodeLang][$h])) { $l = ord($srcText[$i + 1]); if (!isset($this->TableEncode[$this->EncodeLang][$h][$l])) { fseek($this->TableHandle, $l * 2 + $this->TableIndex[$this->EncodeLang][$h]); $this->TableEncode[$this->EncodeLang][$h][$l] = $this->UNICODEtoUTF8( hexdec(bin2hex(fread($this->TableHandle, 2)))); } $tarText .= $this->TableEncode[$this->EncodeLang][$h][$l]; } elseif ($h < 128) { $tarText .= $srcText[$i]; $i--; } } return $tarText; } public static function utf16beToUTF8(&$str) { return self::unicodeToUTF8(unpack('n*', $str)); } public static function utf8ToUTF16BE(&$string, $bom = false) { $out = $bom ? "\xFE\xFF" : ''; if (function_exists('mb_convert_encoding')) { return $out . mb_convert_encoding($string, 'UTF-16BE', 'UTF-8'); } $uni = self::utf8ToUnicode($string); foreach ($uni as $cp) { $out .= pack('n', $cp); } return $out; } public static function unicodeToUTF8(&$str) { $utf8 = ''; foreach ($str as $unicode) { if ($unicode < 128) { $utf8 .= chr($unicode); } elseif ($unicode < 2048) { $utf8 .= chr(192 + (($unicode - ($unicode % 64)) / 64)); $utf8 .= chr(128 + ($unicode % 64)); } else { $utf8 .= chr(224 + (($unicode - ($unicode % 4096)) / 4096)); $utf8 .= chr(128 + ((($unicode % 4096) - ($unicode % 64)) / 64)); $utf8 .= chr(128 + ($unicode % 64)); } } return $utf8; } public static function utf8ToUnicode(&$string) { $unicode = $values = array(); $lookingFor = 1; for ($i = 0, $length = strlen($string); $i < $length; $i++) { $thisValue = ord($string[$i]); if ($thisValue < 128) { $unicode[] = $thisValue; } else { if (count($values) == 0) { $lookingFor = ($thisValue < 224) ? 2 : 3; } $values[] = $thisValue; if (count($values) == $lookingFor) { $unicode[] = ($lookingFor == 3) ? ($values[0] % 16) * 4096 + ($values[1] % 64) * 64 + $values[2] % 64 : ($values[0] % 32) * 64 + $values[1] % 64; $values = array(); $lookingFor = 1; } } } return $unicode; } private static function _getCharset($lang) { switch (strtoupper(substr($lang, 0, 2))) { case 'GB': $lang = 'GBK'; break; case 'UT': $lang = 'UTF8'; break; case 'UN': $lang = 'UNICODE'; break; case 'BI': $lang = 'BIG5'; break; default: $lang = ''; } return $lang; } private static function _isIconv($targeLang) { return function_exists('iconv') && $targeLang != 'BIG5'; } } class FreeDate { public static function getTimeZone() { return function_exists('date_default_timezone_get') ? date_default_timezone_get() : date('e'); } public static function setTimezone($timezone) { function_exists('date_default_timezone_set') ? date_default_timezone_set($timezone) : putenv("TZ={$timezone}"); } public static function format($format = null, $dateTime = null) { return date($format ? $format : 'Y-m-d H:i:s', self::getTimeStamp($dateTime)); } public static function datePart($interval, $dateTime = null) { return date($interval, self::getTimeStamp($dateTime)); } public static function dateDiff($interval, $startDateTime, $endDateTime) { $diff = self::getTimeStamp($endDateTime) - self::getTimeStamp($startDateTime); $retval = 0; switch ($interval) { case "y": $retval = bcdiv($diff, (60 * 60 * 24 * 365)); break; case "m": $retval = bcdiv($diff, (60 * 60 * 24 * 30)); break; case "w": $retval = bcdiv($diff, (60 * 60 * 24 * 7)); break; case "d": $retval = bcdiv($diff, (60 * 60 * 24)); break; case "h": $retval = bcdiv($diff, (60 * 60)); break; case "n": $retval = bcdiv($diff, 60); break; case "s": default: $retval = $diff; break; } return $retval; } public static function dateAdd($interval, $value, $dateTime, $format = null) { $date = getdate(self::getTimeStamp($dateTime)); switch ($interval) { case "y": $date["year"] += $value; break; case "q": $date["mon"] += ($value * 3); break; case "m": $date["mon"] += $value; break; case "w": $date["mday"] += ($value * 7); break; case "d": $date["mday"] += $value; break; case "h": $date["hours"] += $value; break; case "n": $date["minutes"] += $value; break; case "s": default: $date["seconds"] += $value; break; } return self::format($format, mktime($date["hours"], $date["minutes"], $date["seconds"], $date["mon"], $date["mday"], $date["year"])); } public static function getRealDaysInMonthsOfYear($year) { $months = array(31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31); if (self::isLeapYear($year)) { $months[1] = 29; } return $months; } public static function getDaysInMonth($month, $year) { if (1 > $month || 12 < $month) { return 0; } if (!($daysInmonths = self::getRealDaysInMonthsOfYear($year))) { return 0; } return $daysInmonths[$month - 1]; } public static function getDaysInYear($year) { return self::isLeapYear($year) ? 366 : 365; } public static function getRFCDate($date = null) { $time = $date ? is_int($date) ? $date : strtotime($date) : time(); $tz = date('Z', $time); $tzs = ($tz < 0) ? '-' : '+'; $tz = abs($tz); $tz = (int) ($tz / 3600) * 100 + ($tz % 3600) / 60; return sprintf("%s %s%04d", date('D, j M Y H:i:s', $time), $tzs, $tz); } public static function getChinaDate($time = null) { list($y, $m, $d, $w, $h, $_h, $i) = explode(' ', date('Y n j w G g i', $time ? $time : time())); return sprintf('%s年%s月%s日(%s) %s%s:%s', $y, $m, $d, self::getChinaWeek($w), self::getPeriodOfTime($h), $_h, $i); } public static function getChinaWeek($week = null) { $week = $week ? $week : (int) date('w', time()); $weekMap = array("星期天", "星期一", "星期二", "星期三", "星期四", "星期五", "星期六"); return $weekMap[$week]; } public static function getPeriodOfTime($hour = null) { $hour = $hour ? $hour : (int) date('G', time()); $period = ''; if (0 <= $hour && 6 > $hour) { $period = '凌晨'; } elseif (6 <= $hour && 8 > $hour) { $period = '早上'; } elseif (8 <= $hour && 11 > $hour) { $period = '上午'; } elseif (11 <= $hour && 13 > $hour) { $period = '中午'; } elseif (13 <= $hour && 15 > $hour) { $period = '响午'; } elseif (15 <= $hour && 18 > $hour) { $period = '下午'; } elseif (18 <= $hour && 20 > $hour) { $period = '傍晚'; } elseif (20 <= $hour && 22 > $hour) { $period = '晚上'; } elseif (22 <= $hour && 23 >= $hour) { $period = '深夜'; } return $period; } public static function getUTCDate($dateTime = null) { $oldTimezone = self::getTimezone(); if ('UTC' !== strtoupper($oldTimezone)) { self::setTimezone('UTC'); } $date = date('D, d M y H:i:s e', self::getTimeStamp($dateTime)); if ('UTC' !== strtoupper($oldTimezone)) { self::setTimezone($oldTimezone); } return $date; } public static function getMicroTime($mircrotime = null, $get_as_float = false) { return array_sum(explode(' ', $mircrotime ? $mircrotime : microtime($get_as_float))); } public static function isLeapYear($year) { return (0 == $year % 4 && 0 != $year % 100 || 0 == $year % 400); } public static function getTimeStamp($dateTime = null) { return $dateTime ? is_int($dateTime) ? $dateTime : strtotime($dateTime) : time(); } public static function getLastDate($time, $timestamp = null, $format = null, $type = 1) { $timelang = array('second' => '秒前', 'yesterday' => '昨天', 'hour' => '小时前', 'minute' => '分钟前', 'qiantian' => '前天'); $timestamp = $timestamp ? $timestamp : time(); $compareTime = strtotime(self::format('Y-m-d', $timestamp)); $currentTime = strtotime(self::format('Y-m-d', $time)); $decrease = $timestamp - $time; $result = self::format($format, $time); if (0 >= $decrease) { return 1 == $type ? array(self::format('Y-m-d', $time), $result) : array( self::format('Y-m-d m-d H:i', $time), $result); } if ($currentTime == $compareTime) { if (1 == $type) { if (60 >= $decrease) { return array($decrease . $timelang['second'], $result); } return 3600 >= $decrease ? array(ceil($decrease / 60) . $timelang['minute'], $result) : array( ceil($decrease / 3600) . $timelang['hour'], $result); } return array(self::format('H:i', $time), $result); } elseif ($currentTime == $compareTime - 86400) { return 1 == $type ? array($timelang['yesterday'] . " " . self::format('H:i', $time), $result) : array( self::format('m-d H:i', $time), $result); } elseif ($currentTime == $compareTime - 172800) { return 1 == $type ? array($timelang['qiantian'] . " " . self::format('H:i', $time), $result) : array( self::format('m-d H:i', $time), $result); } elseif (strtotime(self::format('Y', $time)) == strtotime(self::format('Y', $timestamp))) { return 1 == $type ? array(self::format('m-d', $time), $result) : array(self::format('m-d H:i', $time), $result); } return 1 == $type ? array(self::format('Y-m-d', $time), $result) : array(self::format('Y-m-d m-d H:i', $time), $result); } } class FreeFile { const READ = 'rb'; const READWRITE = 'rb+'; const WRITE = 'wb'; const WRITEREAD = 'wb+'; const APPEND_WRITE = 'ab'; const APPEND_WRITEREAD = 'ab+'; public static function del($filename) { return @unlink($filename); } public static function savePhpData($fileName, $data, $isBuildReturn = true, $method = self::READWRITE, $ifLock = true) { $temp = "<?php\r\n "; if (!$isBuildReturn && is_array($data)) { foreach ($data as $key => $value) { if (!preg_match('/^\w+$/', $key)) continue; $temp .= "\$" . $key . " = " . FreeString::varToString($value) . ";\r\n"; } $temp .= "\r\n?>"; } else { ($isBuildReturn) && $temp .= " return "; $temp .= FreeString::varToString($data) . ";\r\n?>"; } return self::write($fileName, $temp, $method, $ifLock); } public static function write($fileName, $data, $method = self::READWRITE, $ifLock = false, $ifCheckPath = true, $ifChmod = true) { touch($fileName); if (!$handle = fopen($fileName, $method)) return false; $ifLock && flock($handle, LOCK_EX); $writeCheck = fwrite($handle, $data); $method == self::READWRITE && ftruncate($handle, strlen($data)); fclose($handle); $ifChmod && chmod($fileName, 0777); return $writeCheck; } public static function read($fileName, $method = self::READ) { $data = ''; if (!$handle = fopen($fileName, $method)) return false; while (!feof($handle)) $data .= fgets($handle, 4096); fclose($handle); return $data; } public static function isFile($fileName) { return $fileName ? is_file($fileName) : false; } public static function getInfo($fileName) { return self::isFile($fileName) ? stat($fileName) : array(); } public static function getSuffix($filename) { if (false === ($rpos = strrpos($filename, '.'))) return ''; return substr($filename, $rpos + 1); } public static function dirPath($path) { $path = str_replace('\\', '/', $path); if(substr($path, -1) != '/') $path = $path.'/'; return $path; } public static function dirCreate($path, $mode = 0777) { if(is_dir($path)) return TRUE; $ftp_enable = 0; $path = self::dirPath($path); $temp = explode('/', $path); $cur_dir = ''; $max = count($temp) - 1; for($i=0; $i<$max; $i++) { $cur_dir .= $temp[$i].'/'; if (@is_dir($cur_dir)) continue; @mkdir($cur_dir, 0777,true); @chmod($cur_dir, 0777); } return is_dir($path); } public static function dirCopy($fromdir, $todir) { $fromdir = self::dirPath($fromdir); $todir = self::dirPath($todir); if (!is_dir($fromdir)) return FALSE; if (!is_dir($todir)) self::dirCreate($todir); $list = glob($fromdir.'*'); if (!empty($list)) { foreach($list as $v) { $path = $todir.basename($v); if(is_dir($v)) { self::dirCopy($v, $path); } else { copy($v, $path); @chmod($path, 0777); } } } return TRUE; } public static function dirIconv($in_charset, $out_charset, $dir, $fileexts = 'php|html|htm|shtml|shtm|js|txt|xml') { if($in_charset == $out_charset) return false; $list = self::dirList($dir); foreach($list as $v) { if (preg_match("/\.($fileexts)/i", $v) && is_file($v)){ file_put_contents($v, iconv($in_charset, $out_charset, file_get_contents($v))); } } return true; } public static function dirList($path, $exts = '', $list= array()) { $path = self::dirPath($path); $files = glob($path.'*'); foreach($files as $v) { $fileext = fileext($v); if (!$exts || preg_match("/\.($exts)/i", $v)) { $list[] = $v; if (is_dir($v)) { $list = self::dirList($v, $exts, $list); } } } return $list; } public static function dirTouch($path, $mtime = TIME, $atime = TIME) { if (!is_dir($path)) return false; $path = self::dirPath($path); if (!is_dir($path)) touch($path, $mtime, $atime); $files = glob($path.'*'); foreach($files as $v) { is_dir($v) ? self::dirTouch($v, $mtime, $atime) : touch($v, $mtime, $atime); } return true; } public static function dirTree($dir, $parentid = 0, $dirs = array()) { global $id; if ($parentid == 0) $id = 0; $list = glob($dir.'*'); foreach($list as $v) { if (is_dir($v)) { $id++; $dirs[$id] = array('id'=>$id,'parentid'=>$parentid, 'name'=>basename($v), 'dir'=>$v.'/'); $dirs = self::dirTree($v.'/', $id, $dirs); } } return $dirs; } public static function dirDelete($dir) { $dir = self::dirPath($dir); if (!is_dir($dir)) return FALSE; $list = glob($dir.'*'); foreach($list as $v) { is_dir($v) ? self::dirDelete($v) : @unlink($v); } return @rmdir($dir); } } class FreeFolder { const READ_ALL = '0'; const READ_FILE = '1'; const READ_DIR = '2'; public static function read($dir, $mode = self::READ_ALL) { if (!$handle = @opendir($dir)) return array(); $files = array(); while (false !== ($file = @readdir($handle))) { if ('.' === $file || '..' === $file) continue; if ($mode === self::READ_DIR) { if (self::isDir($dir . '/' . $file)) $files[] = $file; } elseif ($mode === self::READ_FILE) { if (FreeFile::isFile($dir . '/' . $file)) $files[] = $file; } else $files[] = $file; } @closedir($handle); return $files; } public static function rm($dir, $f = false) { return $f ? self::clearRecur($dir, true) : @rmdir($dir); } public static function clear($dir, $delFolder = false) { if (!self::isDir($dir)) return false; if (!$handle = @opendir($dir)) return false; while (false !== ($file = readdir($handle))) { if ('.' === $file[0] || '..' === $file[0]) continue; $filename = $dir . '/' . $file; if (FreeFile::isFile($filename)) FreeFile::del($filename); } $delFolder && @rmdir($dir); @closedir($handle); return true; } public static function clearRecur($dir, $delFolder = false) { if (!self::isDir($dir)) return false; if (!$handle = @opendir($dir)) return false; while (false !== ($file = readdir($handle))) { if ('.' === $file || '..' === $file) continue; $_path = $dir . '/' . $file; if (self::isDir($_path)) { self::clearRecur($_path, $delFolder); } elseif (FreeFile::isFile($_path)) FreeFile::del($_path); } $delFolder && @rmdir($dir); @closedir($handle); return true; } public static function isDir($dir) { return $dir ? is_dir($dir) : false; } public static function getInfo($dir) { return self::isDir($dir) ? stat($dir) : array(); } public static function mk($path, $permissions = 0777) { return @mkdir($path, $permissions); } public static function mkRecur($path, $permissions = 0777) { if (is_dir($path)) return true; $_path = dirname($path); if ($_path !== $path) self::mkRecur($_path, $permissions); return self::mk($path, $permissions); } } class FreeImage { public static function makeThumb($srcFile, $dstFile, $dstW, $dstH, $isProportion = FALSE) { if (false === ($minitemp = self::getThumbInfo($srcFile, $dstW, $dstH, $isProportion))) return false; list($imagecreate, $imagecopyre) = self::getImgcreate($minitemp['type']); if (!$imagecreate) return false; $imgwidth = $minitemp['width']; $imgheight = $minitemp['height']; $srcX = $srcY = $dstX = $dstY =0; if (!$isProportion) { $dsDivision = $imgheight / $imgwidth; $fixDivision = $dstH / $dstW; if ($dsDivision > $fixDivision) { $tmp = $imgwidth * $fixDivision; $srcY = round(($imgheight - $tmp) / 2); $imgheight = $tmp; } else { $tmp = $imgheight / $fixDivision; $srcX = round(($imgwidth - $tmp) / 2); $imgwidth = $tmp; } } $thumb = $imagecreate($minitemp['dstW'], $minitemp['dstH']); if (function_exists('imagecolorallocate') && function_exists('imagecolortransparent')) { $black = imagecolorallocate($thumb, 0, 0, 0); imagecolortransparent($thumb, $black); } $imagecopyre($thumb, $minitemp['source'], $dstX, $dstY, $srcX, $srcY, $minitemp['dstW'], $minitemp['dstH'], $imgwidth, $imgheight); self::makeImg($minitemp['type'], $thumb, $dstFile); imagedestroy($thumb); return array('width' => $minitemp['dstW'], 'height' => $minitemp['dstH'], 'type' => $minitemp['type']); } public static function makeWatermark($source, $waterPos = 0, $waterImg = '', $waterText = '', $attribute = '', $waterPct = 50, $waterQuality = 75, $dstsrc = null) { $sourcedb = $waterdb = array(); if (false === ($sourcedb = self::getImgInfo($source))) return false; if (!$waterImg && !$waterText) return false; imagealphablending($sourcedb['source'], true); if ($waterImg) { $waterdb = self::getImgInfo($waterImg); list($wX, $wY) = self::getWaterPos($waterPos, $sourcedb, $waterdb, 1); if ($waterdb['type'] == 'png') { $tmp = imagecreatetruecolor($sourcedb['width'], $sourcedb['height']); imagecopy($tmp, $sourcedb['source'], 0, 0, 0, 0, $sourcedb['width'], $sourcedb['height']); imagecopy($tmp, $waterdb['source'], $wX, $wY, 0, 0, $waterdb['width'], $waterdb['height']); $sourcedb['source'] = $tmp; } else { imagecopymerge($sourcedb['source'], $waterdb['source'], $wX, $wY, 0, 0, $waterdb['width'], $waterdb['height'], $waterPct); } } elseif ($waterText) { list($fontFile, $charset, $color, $waterFont) = self::checkAttribute($attribute); empty($waterFont) && $waterFont = 12; $temp = imagettfbbox($waterFont, 0, $fontFile, $waterText); $waterdb['width'] = $temp[2] - $temp[6]; $waterdb['height'] = $temp[3] - $temp[7]; unset($temp); list($wX, $wY) = self::getWaterPos($waterPos, $sourcedb, $waterdb, 2); if (strlen($color) != 7) return false; $R = hexdec(substr($color, 1, 2)); $G = hexdec(substr($color, 3, 2)); $B = hexdec(substr($color, 5)); self::changeCharset($charset) && $waterText = mb_convert_encoding($waterText, 'UTF-8', $charset); imagettftext($sourcedb['source'], $waterFont, 0, $wX, $wY, imagecolorallocate($sourcedb['source'], $R, $G, $B), $fontFile, $waterText); } $dstsrc && $source = $dstsrc; self::makeImg($sourcedb['type'], $sourcedb['source'], $source, $waterQuality); isset($waterdb['source']) && imagedestroy($waterdb['source']); imagedestroy($sourcedb['source']); return true; } private static function checkAttribute($attribute) { $attribute = is_string($attribute) ? array($attribute) : $attribute; if (!isset($attribute[1]) || !$attribute[1]) $attribute[1] = 'UTF-8'; if (!isset($attribute[2]) || !$attribute[2]) $attribute[2] = '#FF0000'; if (!isset($attribute[3]) || !$attribute[3]) $attribute[3] = 12; return $attribute; } private static function changeCharset($charset) { $charset = strtolower($charset); return !in_array($charset, array('utf8', 'utf-8')); } private static function getWaterPos($waterPos, $sourcedb, $waterdb, $markType) { if (is_array($waterPos)) return $waterPos; $wX = $wY = 0; switch (intval($waterPos)) { case 0 : $wX = rand(0, ($sourcedb['width'] - $waterdb['width'])); $wY = $markType == 1 ? rand(0, ($sourcedb['height'] - $waterdb['height'])) : rand($waterdb['height'], $sourcedb['height']); break; case 1 : $wX = 5; $wY = $markType == 1 ? 5 : $waterdb['height']; break; case 2: $wX = ($sourcedb['width'] - $waterdb['width']) / 2; $wY = $markType == 1 ? 5 : $waterdb['height']; break; case 3: $wX = $sourcedb['width'] - $waterdb['width'] - 5; $wY = $markType == 1 ? 5 : $waterdb['height']; break; case 4: $wX = 5; $wY = $markType == 1 ? $sourcedb['height'] - $waterdb['height'] - 5 : $sourcedb['height'] - 5; break; case 5: $wX = ($sourcedb['width'] - $waterdb['width']) / 2; $wY = $markType == 1 ? $sourcedb['height'] - $waterdb['height'] - 5 : $sourcedb['height'] - 5; break; case 6: $wX = $sourcedb['width'] - $waterdb['width'] - 5; $wY = $markType == 1 ? $sourcedb['height'] - $waterdb['height'] - 5 : $sourcedb['height'] - 5; break; default: $wX = ($sourcedb['width'] - $waterdb['width']) / 2; $wY = $markType == 1 ? ($sourcedb['height'] - $waterdb['height']) / 2 : ($sourcedb['height'] + $waterdb['height']) / 2; break; } return array($wX, $wY); } private static function getThumbInfo($srcFile, $dstW, $dstH, $isProportion= FALSE) { if (false === ($imgdata = self::getImgInfo($srcFile))) return false; if ($imgdata['width'] <= $dstW && $imgdata['height'] <= $dstH) return false; $imgdata['dstW'] = $dstW; $imgdata['dstH'] = $dstH; if (empty($dstW) && $dstH > 0 && $imgdata['height'] > $dstH) { $imgdata['dstW'] = !$isProportion ? $dstH : round($dstH / $imgdata['height'] * $imgdata['width']); } elseif (empty($dstH) && $dstW > 0 && $imgdata['width'] > $dstW) { $imgdata['dstH'] = !$isProportion ? $dstW : round($dstW / $imgdata['width'] * $imgdata['height']); } elseif ($dstW > 0 && $dstH > 0) { if (($imgdata['width'] / $dstW) < ($imgdata['height'] / $dstH)) { $imgdata['dstW'] = !$isProportion ? $dstW : round($dstH / $imgdata['height'] * $imgdata['width']); } if (($imgdata['width'] / $dstW) > ($imgdata['height'] / $dstH)) { $imgdata['dstH'] = !$isProportion ? $dstH : round($dstW / $imgdata['width'] * $imgdata['height']); } } else { $imgdata = false; } return $imgdata; } public static function getImgInfo($srcFile) { if (false === ($imgdata = self::getImgSize($srcFile))) return false; $imgdata['type'] = self::getTypes($imgdata['type']); if (empty($imgdata) || !function_exists('imagecreatefrom' . $imgdata['type'])) return false; $imagecreatefromtype = 'imagecreatefrom' . $imgdata['type']; $imgdata['source'] = $imagecreatefromtype($srcFile); !$imgdata['width'] && $imgdata['width'] = imagesx($imgdata['source']); !$imgdata['height'] && $imgdata['height'] = imagesy($imgdata['source']); return $imgdata; } private static function getImgSize($srcFile, $srcExt = null) { empty($srcExt) && $srcExt = strtolower(substr(strrchr($srcFile, '.'), 1)); $srcdata = array(); $exts = array('jpg', 'jpeg', 'jpe', 'jfif'); in_array($srcExt, $exts) && $srcdata['type'] = 2; if (false === ($info = getimagesize($srcFile))) return false; list($srcdata['width'], $srcdata['height'], $srcdata['type']) = $info; if (!$srcdata['type'] || ($srcdata['type'] == 1 && in_array($srcExt, $exts))) return false; return $srcdata; } private static function getImgcreate($imagetype) { if ($imagetype != 'gif' && function_exists('imagecreatetruecolor') && function_exists('imagecopyresampled')) { return array('imagecreatetruecolor', 'imagecopyresampled'); } if (function_exists('imagecreate') && function_exists('imagecopyresized')) { return array('imagecreate', 'imagecopyresized'); } return array('', ''); } private static function makeImg($type, $image, $filename, $quality = '75') { $makeimage = 'image' . $type; if (!function_exists($makeimage)) return false; if ($type == 'jpeg') { $makeimage($image, $filename, $quality); } else { $makeimage($image, $filename); } return true; } private static function getTypes($id) { $imageTypes = array(1 => 'gif', 2 => 'jpeg', '3' => 'png', 6 => 'bmp'); return isset($imageTypes[$id]) ? $imageTypes[$id] : ''; } } class FreePack { const STRIP_SELF = 'stripWhiteSpaceBySelf'; const STRIP_PHP = 'stripWhiteSpaceByPhp'; const STRIP_TOKEN = 'stripWhiteSpaceByToken'; private $packList = array(); private $contentInjectionPosition; private $contentInjectionCallBack = ''; public function packFromFileList($fileList, $dst, $packMethod = FreePack::STRIP_PHP, $compress = true) { if (empty($dst) || empty($fileList)) return false; $content = array(); $this->readContentFromFileList($fileList, $packMethod, $content); $replace = $compress ? ' ' : "\n"; $content = implode($replace, $content); $content = $this->callBack($content, $replace); $content = $this->stripNR($content, $replace); $content = $this->stripPhpIdentify($content, ''); return FreeFile::write($dst, '<?php' . $replace . $content . '?>'); } public function stripWhiteSpaceByPhp($filename) { return php_strip_whitespace($filename); } public function stripWhiteSpaceBySelf($filename, $compress = true) { $content = $this->getContentFromFile($filename); $content = $this->stripComment($content, ''); return $this->stripSpace($content, ' '); } public function stripWhiteSpaceByToken($filename) { $content = $this->getContentFromFile($filename); $compressContent = ''; $lastToken = 0; foreach (token_get_all($content) as $key => $token) { if (is_array($token)) { if (in_array($token[0], array(T_COMMENT, T_WHITESPACE, T_DOC_COMMENT))) { continue; } $compressContent .= ' ' . $token[1]; } else { $compressContent .= $token; } $lastToken = $token[0]; } return $compressContent; } public function readContentFromFileList(array $fileList, $packMethod = FreePack::STRIP_PHP, &$content = array()) { if (empty($fileList) || false === $this->isValidatePackMethod($packMethod)) return array(); foreach ($fileList as $key => $value) { $parents = class_parents($key); $_fileList = $this->buildFileList($parents, $fileList); $this->readContentFromFileList($_fileList, $packMethod, $content); $implements = class_implements($key); $_fileList = $this->buildFileList($implements, $fileList); $this->readContentFromFileList($_fileList, $packMethod, $content); if (in_array($key, $this->packList)) continue; if (is_file($value)) { $content[] = $this->$packMethod($value); $this->packList[] = $key; } } } public function stripComment($content, $replace = '') { return preg_replace('/(?:\/\*.*\*\/)*|(?:\/\/[^\r\n]*[\r\n])*/Us', $replace, $content); } public function stripNR($content, $replace = array('\n','\r\n','\r')) { return preg_replace('/[\n\r]+/', $replace, $content); } public function stripSpace($content, $replace = ' ') { return preg_replace('/[ ]+/', $replace, $content); } public function stripPhpIdentify($content, $replace = '') { return preg_replace('/(?:<\?(?:php)*)|(\?>)/i', $replace, $content); } public function stripStrByRule($content, $rule, $replace = '') { return preg_replace("/$rule/", $replace, $content); } public function stripImport($content, $replace = '') { $str = preg_match_all('/L[\t ]*::[\t ]*import[\t ]*\([\t ]*[\'\"]([^$][\w\.:]+)[\"\'][\t ]*\)[\t ]*/', $content, $matchs); if ($matchs[1]) { foreach ($matchs[1] as $key => $value) { $name = substr($value, strrpos($value, '.') + 1); if (preg_match("/(abstract[\t ]*|class|interface)[\t ]+$name/i", $content)) { $strip = str_replace(array('(', ')'), array('\(', '\)'), addslashes($matchs[0][$key])) . '[\t ]*;'; $content = $this->stripStrByRule($content, $strip, $replace); } } } return $content; } public function getContentFromFile($filename) { if (is_file($filename)) { $content = ''; $fp = fopen($filename, "r"); while (!feof($fp)) { $line = fgets($fp); if (in_array(strlen($line), array(2, 3)) && in_array(ord($line), array(9, 10, 13))) continue; $content .= $line; } fclose($fp); return $content; } return false; } private function buildFileList(array $list, $fileList) { $_temp = array(); foreach ($list as $fileName) { foreach ($fileList as $key => $value) { if ($key == $fileName) { $_temp[$key] = $value; break; } } } return $_temp; } public function setContentInjectionCallBack($contentInjectionCallBack, $position = 'before') { if (!in_array($position, array('before', 'after'))) $position = 'before'; $this->contentInjectionPosition = $position; $this->contentInjectionCallBack = $contentInjectionCallBack; } public function callBack($content, $replace = '') { if ($this->contentInjectionCallBack !== '') { $_content = call_user_func_array($this->contentInjectionCallBack, array($this->packList)); if ($this->contentInjectionPosition == 'before') { $content = $replace . $_content . $content; } elseif ($this->contentInjectionPosition == 'after') { $content .= $replace . $_content . $replace; } } return $content; } private function isValidatePackMethod($packMethod) { return method_exists($this, $packMethod) && in_array($packMethod, array(FreePack::STRIP_PHP, FreePack::STRIP_SELF, FreePack::STRIP_TOKEN)); } } class FreeSecurity { const SERCRETKEY = 'DAIZHONGWEI'; public static function escapeHTML($str) { if (!is_string($str)) return $str; return htmlspecialchars($str, ENT_QUOTES); } public static function escapeArrayHTML($array) { if (!is_array($array) || count($array) > 100) return $array; $_tmp = array(); foreach ($array as $key => $value) { is_string($key) && $key = self::escapeHTML($key); $_tmp[$key] = self::escapeHTML($value); } return $_tmp; } public static function encrypt($str, $key=self::SERCRETKEY, $iv = '') { return self::authcode($str,'ENCODE',$key,$iv); } public static function decrypt($str, $key=self::SERCRETKEY, $iv = '') { return self::authcode($str,'DECODE',$key,$iv); } public static function createToken() { return self::generateGUID(); } public static function generateGUID() { return substr(md5(self::generateRandStr(8) . microtime()), -16); } public static function generateRandStr($length) { $randstr = ""; for ($i = 0; $i < (int) $length; $i++) { $randnum = mt_rand(0, 61); if ($randnum < 10) { $randstr .= chr($randnum + 48); } else if ($randnum < 36) { $randstr .= chr($randnum + 55); } else { $randstr .= chr($randnum + 61); } } return $randstr; } public static function escapePath($filePath, $ifCheck = false) { $_tmp = array("'" => '', '#' => '', '=' => '', '`' => '', '$' => '', '%' => '', '&' => '', ';' => ''); $_tmp['://'] = $_tmp["\0"] = ''; $ifCheck && $_tmp['..'] = ''; if (strtr($filePath, $_tmp) == $filePath) return preg_replace('/[\/\\\]{1,}/i', '/', $filePath); if (WIND_DEBUG & 2) { $WindLogger = Free::loadClass('WindLogger',PC_PATH . 'libs/log',1); $WindLogger->info( "[utility.FreeSecurity.escapePath] file path is illegal.\r\n\tFilePath:" . $filePath); } throw new FreeException('[utility.FreeSecurity.escapePath] file path is illegal'); } public static function authcode($string, $operation = 'DECODE', $key = 'user_sercretkey', $expiry = 0) { $ckey_length = 1; $key = md5($key ? $key : 1234); $keya = md5(substr($key, 0, 16)); $keyb = md5(substr($key, 16, 16)); $keyc = 'a'; $cryptkey = $keya . md5($keya . $keyc); $key_length = strlen($cryptkey); $string = $operation == 'DECODE' ? base64_decode(substr($string, $ckey_length)) : sprintf('%010d', $expiry ? $expiry : 0) . substr(md5($string . $keyb), 0, 16) . $string; $string_length = strlen($string); $result = ''; $box = range(0, 255); $rndkey = array(); for ($i = 0; $i <= 255; $i++) { $rndkey[$i] = ord($cryptkey[$i % $key_length]); } for ($j = $i = 0; $i < 256; $i++) { $j = ($j + $box[$i] + $rndkey[$i]) % 256; $tmp = $box[$i]; $box[$i] = $box[$j]; $box[$j] = $tmp; } for ($a = $j = $i = 0; $i < $string_length; $i++) { $a = ($a + 1) % 256; $j = ($j + $box[$a]) % 256; $tmp = $box[$a]; $box[$a] = $box[$j]; $box[$j] = $tmp; $result .= chr(ord($string[$i]) ^ ($box[($box[$a] + $box[$j]) % 256])); } if ($operation == 'DECODE') { if ((substr($result, 0, 10) == 0 || substr($result, 0, 10) > 0) && substr($result, 10, 16) == substr(md5(substr($result, 26) . $keyb), 0, 16)) { return substr($result, 26); } else { return ''; } } else { return $keyc . str_replace('=', '', base64_encode($result)); } } } class FreeCookie { public static function set($name, $value = null, $encode = true, $expires = null, $path = null, $domain = null, $secure = false, $httponly = false) { if (empty($name)) return false; $encode && $value && $value = base64_encode(serialize($value)); $path = $path ? $path : '/'; setcookie($name, $value, $expires, $path, $domain, $secure, $httponly); return true; } public static function delete($name) { if (self::exist($name)) { self::set($name, ''); unset($_COOKIE[$name]); } return true; } public static function get($name, $dencode = true) { if (self::exist($name)) { $value = $_COOKIE[$name]; $value && $dencode && $value = unserialize(base64_decode($value)); return $value ? $value : $value; } return false; } public static function deleteAll() { $_COOKIE = array(); return true; } public static function exist($name) { return isset($_COOKIE[$name]); } } class FreeSession { static public function set($key,$value) { if(is_array($_SESSION[$key])) { $_SESSION[$key] = array_merge($_SESSION[$key],$value); }else{ $_SESSION[$key] = $value; } } static public function get($key) { return isset($_SESSION[$key]) ? $_SESSION[$key] : NULL; } static public function delete($key) { if(isset($_SESSION[$key]) ) { unset($_SESSION[$key]); } } } class FreeString { const UTF8 = 'utf-8'; const GBK = 'gbk'; public static function substr($string, $start, $length, $charset = self::UTF8, $dot = false) { switch (strtolower($charset)) { case self::GBK: $string = self::substrForGbk($string, $start, $length, $dot); break; default: $string = self::substrForUtf8($string, $start, $length, $dot); break; } return $string; } public static function strlen($string, $charset = self::UTF8) { $len = strlen($string); $i = $count = 0; $charset = strtolower(substr($charset, 0, 3)); while ($i < $len) { if (ord($string[$i]) <= 129) $i++; else switch ($charset) { case 'utf': $i += 3; break; default: $i += 2; break; } $count++; } return $count; } public static function varToString($input, $indent = '') { switch (gettype($input)) { case 'string': return "'" . str_replace(array("\\", "'"), array("\\\\", "\\'"), $input) . "'"; case 'array': $output = "array(\r\n"; foreach ($input as $key => $value) { $output .= $indent . "\t" . self::varToString($key, $indent . "\t") . ' => ' . self::varToString( $value, $indent . "\t"); $output .= ",\r\n"; } $output .= $indent . ')'; return $output; case 'boolean': return $input ? 'true' : 'false'; case 'NULL': return 'NULL'; case 'integer': case 'double': case 'float': return "'" . (string) $input . "'"; } return 'NULL'; } public static function substrForUtf8($string, $start, $length = null, $dot = false) { if (empty($string)) return ''; $strlen = strlen($string); $length = $length ? (int) $length : $strlen; $substr = ''; $chinese = $word = 0; for ($i = 0, $j = 0; $i < (int) $start; $i++) { if (0xa0 < ord(substr($string, $j, 1))) { $chinese++; $j += 2; } else { $word++; } $j++; } $start = $word + 3 * $chinese; for ($i = $start, $j = $start; $i < $start + $length; $i++) { if (0xa0 < ord(substr($string, $j, 1))) { $substr .= substr($string, $j, 3); $j += 2; } else { $substr .= substr($string, $j, 1); } $j++; } (strlen($substr) < $strlen) && $dot && $substr .= "..."; return $substr; } public static function substrForGbk($string, $start, $length = null, $dot = false) { if (empty($string) || !is_int($start) || ($length && !is_int($length))) { return ''; } $strlen = strlen($string); $length = $length ? $length : $strlen; $substr = ''; $chinese = $word = 0; for ($i = 0, $j = 0; $i < $start; $i++) { if (0xa0 < ord(substr($string, $j, 1))) { $chinese++; $j++; } else { $word++; } $j++; } $start = $word + 2 * $chinese; for ($i = $start, $j = $start; $i < $start + $length; $i++) { if (0xa0 < ord(substr($string, $j, 1))) { $substr .= substr($string, $j, 2); $j++; } else { $substr .= substr($string, $j, 1); } $j++; } (strlen($substr) < $strlen) && $dot && $substr .= "..."; return $substr; } public static function strlenForUtf8($str) { $i = $count = 0; $len = strlen($str); while ($i < $len) { $chr = ord($str[$i]); $count++; $i++; if ($i >= $len) break; if ($chr & 0x80) { $chr <<= 1; while ($chr & 0x80) { $i++; $chr <<= 1; } } } return $count; } public static function strlenForGbk($string) { $len = strlen($string); $i = $count = 0; while ($i < $len) { ord($string[$i]) > 129 ? $i += 2 : $i++; $count++; } return $count; } public static function trim($string) { if(is_array($string)) { foreach($string as $key => $val) { $string[$key] = self::trim($val); } }else{ return trim($string); } return $string; } public static function genUuid() { return uniqid(); } } class FreeValidator { public static function isTelPhone($phone) { return 0 < preg_match('/^\+?[0\s]*[\d]{0,4}[\-\s]?\d{0,6}[\-\s]?\d{4,12}$/', $phone); } public static function isTelNumber($number) { return 0 < preg_match('/^\+?[0\s]*[\d]{0,4}[\-\s]?\d{4,12}$/', $number); } public static function isQQ($qq) { return 0 < preg_match('/^[1-9]\d{4,14}$/', $qq); } public static function isZipcode($zipcode) { return 0 < preg_match('/^\d{4,8}$/', $zipcode); } public static function hasEmail($string, &$matches = array(), $ifAll = false) { return 0 < self::validateByRegExp("/\w+([-+.']\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*/", $string); } public static function isEmail($string) { return 0 < preg_match("/^\w+(?:[-+.']\w+)*@\w+(?:[-.]\w+)*\.\w+(?:[-.]\w+)*$/", $string); } public static function hasIdCard($string, &$matches = array(), $ifAll = false) { return 0 < self::validateByRegExp("/\d{17}[\d|X]|\d{15}/", $string, $matches, $ifAll); } public static function isIdCard($string) { return 0 < preg_match("/^(?:\d{17}[\d|X]|\d{15})$/", $string); } public static function hasUrl($string, &$matches = array(), $ifAll = false) { return 0 < self::validateByRegExp('/http(s)?:\/\/([\w-]+\.)+[\w-]+(\/[\w- .\/?%&=]*)?/', $string, $matches, $ifAll); } public static function isUrl($string) { return 0 < preg_match('/^(?:http(?:s)?:\/\/(?:[\w-]+\.)+[\w-]+(?:\:\d+)*+(?:\/[\w- .\/?%&=]*)?)$/', $string); } public static function hasChinese($string, &$matches = array(), $ifAll = false) { return 0 < self::validateByRegExp('/[\x{4e00}-\x{9fa5}]+/u', $string, $matches, $ifAll); } public static function isChinese($string) { return 0 < preg_match('/^[\x{4e00}-\x{9fa5}]+$/u', $string); } public static function hasHtml($string, &$matches = array(), $ifAll = false) { return 0 < self::validateByRegExp('/<(.*)>.*|<(.*)\/>/', $string, $matches, $ifAll); } public static function isHtml($string) { return 0 < preg_match('/^<(.*)>.*|<(.*)\/>$/', $string); } public static function hasIpv4($string, &$matches = array(), $ifAll = false) { return 0 < self::validateByRegExp('/((25[0-5]|2[0-4]\d|1\d{2}|0?[1-9]\d|0?0?\d)\.){3}(25[0-5]|2[0-4]\d|1\d{2}|0?[1-9]\d|0?0?\d)/', $string, $matches, $ifAll); } public static function isIpv4($string) { return 0 < preg_match('/(?:(?:25[0-5]|2[0-4]\d|1\d{2}|0?[1-9]\d|0?0?\d)\.){3}(?:25[0-5]|2[0-4]\d|1\d{2}|0?[1-9]\d|0?0?\d)/', $string); } public static function hasIpv6($string, &$matches = array(), $ifAll = false) { return 0 < self::validateByRegExp('/\A((([a-f0-9]{1,4}:){6}|
										::([a-f0-9]{1,4}:){5}|
										([a-f0-9]{1,4})?::([a-f0-9]{1,4}:){4}|
										(([a-f0-9]{1,4}:){0,1}[a-f0-9]{1,4})?::([a-f0-9]{1,4}:){3}|
										(([a-f0-9]{1,4}:){0,2}[a-f0-9]{1,4})?::([a-f0-9]{1,4}:){2}|
										(([a-f0-9]{1,4}:){0,3}[a-f0-9]{1,4})?::[a-f0-9]{1,4}:|
										(([a-f0-9]{1,4}:){0,4}[a-f0-9]{1,4})?::
									)([a-f0-9]{1,4}:[a-f0-9]{1,4}|
										(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\.){3}
										([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])
									)|((([a-f0-9]{1,4}:){0,5}[a-f0-9]{1,4})?::[a-f0-9]{1,4}|
										(([a-f0-9]{1,4}:){0,6}[a-f0-9]{1,4})?::
									)
								)\Z/ix', $string, $matches, $ifAll); } public static function isIpv6($string) { return 0 < preg_match('/\A(?:(?:(?:[a-f0-9]{1,4}:){6}|
										::(?:[a-f0-9]{1,4}:){5}|
										(?:[a-f0-9]{1,4})?::(?:[a-f0-9]{1,4}:){4}|
										(?:(?:[a-f0-9]{1,4}:){0,1}[a-f0-9]{1,4})?::(?:[a-f0-9]{1,4}:){3}|
										(?:(?:[a-f0-9]{1,4}:){0,2}[a-f0-9]{1,4})?::(?:[a-f0-9]{1,4}:){2}|
										(?:(?:[a-f0-9]{1,4}:){0,3}[a-f0-9]{1,4})?::[a-f0-9]{1,4}:|
										(?:(?:[a-f0-9]{1,4}:){0,4}[a-f0-9]{1,4})?::
									)(?:[a-f0-9]{1,4}:[a-f0-9]{1,4}|
										(?:(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\.){3}
										(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])
									)|(?:(?:(?:[a-f0-9]{1,4}:){0,5}[a-f0-9]{1,4})?::[a-f0-9]{1,4}|
										(?:(?:[a-f0-9]{1,4}:){0,6}[a-f0-9]{1,4})?::
									)
								)\Z/ix', $string); } public static function hasScript($string, &$matches = array(), $ifAll = false) { return 0 < self::validateByRegExp('/<script(.*?)>([^\x00]*?)<\/script>/', $string, $matches, $ifAll); } public static function isScript($string) { return 0 < preg_match('/<script(?:.*?)>(?:[^\x00]*?)<\/script>/', $string); } public static function isNonNegative($number) { return is_numeric($number) && 0 <= $number; } public static function isPositive($number) { return is_numeric($number) && 0 < $number; } public static function isNegative($number) { return is_numeric($number) && 0 > $number; } public static function isRequired($value) { return !empty($value); } public static function isLegalLength($string, $length, $charset = 'utf8') { Free::import('WIND:utility.FreeString'); return FreeString::strlen($string, $charset) > (int) $length; } private static function validateByRegExp($regExp, $string, &$matches = array(), $ifAll = false) { return $ifAll ? preg_match_all($regExp, $string, $matches) : preg_match($regExp, $string, $matches); } public static function isPassWord($password, $min = 6, $max = 20) { $strlen = strlen($password); if ($strlen >= $min && $strlen <= $max) return true; return false; } public static function isRealName($username) { $strlen = strlen($username); if (self::isBadWord($username) || !preg_match("/^[" . chr(0x81) . "-" . chr(0xfe) . "]+$/", $username)) { return false; } elseif (12 < $strlen || $strlen < 6) { return false; } return true; } public static function isNickName($username) { $strlen = strlen($username); if (self::isBadWord($username) || !preg_match("/^[a-zA-Z0-9_\x7f-\xff][a-zA-Z0-9_\x7f-\xff]+$/", $username)) { return false; } elseif (20 <= $strlen || $strlen < 2) { return false; } return true; } public static function isUserName($username,$min=6,$max=20) { $strlen = strlen($username); if (self::isBadWord($username) || !preg_match("/^[a-zA-Z][a-zA-Z0-9_]{0,99}$/", $username)) { return false; } elseif ($max < $strlen || $strlen < $min) { return false; } return true; } public static function isBadWord($string) { $badwords = array("\\", '&', ' ', "'", '"', '/', '*', ',', '<', '>', "\r", "\t", "\n", "#"); foreach ($badwords as $value) { if (strpos($string, $value) !== FALSE) { return TRUE; } } return FALSE; } } interface IFreeConverter { public function convert($str); } Free::setConfig(array ( 'application' => array ( 'Web' => array ( 'version' => 'base', 'template-path' => 'view/base/webtemplates/', 'controller-path' => 'web', 'route' => 'index/index/init', 'filter' => array ( 'front_filter' => 'src/library/FrontFilter', ), ), ), 'cache' => array ( 'file1' => array ( 'type' => 'file', 'debug' => true, 'pconnect' => 0, 'autoconnect' => 0, ), 'memcache' => array ( 0 => array ( 'hostname' => '10.8.6.239', 'port' => 11211, 'timeout' => 1, ), ), 'mongo_db' => array ( 'connect' => array ( 0 => array ( 'type' => 'mongo', 'hostname' => '127.0.0.1', 'database' => 'FREE', 'username' => '', 'password' => '', 'port' => '27017', 'autoconnect' => 0, ), ), 'timeout' => 200, ), 'redis' => array ( 'type' => 'redis', 'servers' => array ( 0 => array ( 'hostname' => '127.0.0.1', 'port' => '6379', 'timeout' => '0', ), ), ), ), 'component' => array ( 'db' => 'free/libs/db/FreeMysqlDb', 'cache' => 'free/libs/cache/FreeFileCache', 'session' => 'free/libs/session/FreeFileSession', 'excel' => 'src/component/excel/PHPExcel', ), 'database' => array ( 'oracle' => array ( 'hostname' => '127.0.0.1', 'database' => '', 'username' => 'FREE', 'password' => 'FREE', 'servicename' => 'XE', 'charset' => 'utf8', 'debug' => true, 'pconnect' => 1, 'autoconnect' => 0, ), 'mysql' => array ( 'database' => 'free', 'hostname' => '127.0.0.1', 'username' => 'root', 'password' => '', 'tablepre' => 'T_', 'charset' => 'utf8', 'debug' => true, 'pconnect' => 0, 'autoconnect' => 0, ), ), 'system' => array ( 'web_domain' => 'http://www.myhost.com/free/', 'web_path' => '/free/', 'session_ttl' => 7200, 'session_n' => 0, 'cookie_domain' => '', 'cookie_path' => '/', 'cookie_pre' => 'pGClX_', 'cookie_ttl' => 0, 'tablepre' => 'T_', 'upload_path' => 'E:\\git\\free\\upload/', 'upload_url' => '/free/upload/', 'js_path' => '/free/statics/js/', 'css_path' => '/free/statics/css/', 'img_path' => '/free/statics/images/', 'charset' => 'utf-8', 'timezone' => 'Etc/GMT-8', 'is_admin_log' => 1, 'errorlog' => 1, 'gzip' => 1, 'lang' => 'zh-cn', 'lock_ex' => '1', 'is_check_csrf' => 1, ), ));